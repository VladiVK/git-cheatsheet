# Git CheatSheet

## Конфигурация

---

`git init` - создает пустой репозитоий в корне проекта

> GIT не умеет работать с упустыми папками: надо что-то туда положить: обычно это `.gitkeep`

`cat .git/config` - данные о репозитории

если локально указать данные о себе под конкретный проект:

`git config user.name "Louis-Ferdinand"`, то они выведутся

`git config --list --global ` - смотрим все глобальные настройки

`cat ~/.gitconfig ` - проще всего смотреть настройки

## Alias

---

`git config --global alias.c config` - теперь просто жмем `git c`

`git config --global alias.c 'config --global'` - теперь просто жмем `git c --list`

## Общие моменты

---

`git log --oneline` - должен показать все коммиты

`git status`

`git add file.txt `

`git add .` - add everything / текущее

`git add -A` - вообще все индексирует начиная с корня проекта

Если после `git add .` мы удалили `file-one.txt`,

то нужно снова провести `git add .` или `git add file-one.txt`
то есть обновить стайджинг ареа

## Удаление

---

`git rm file.txt ` - полное удаление файла ( и индекс и рабочий каталог )

`git rm -r src` - полное удаление директории ( и индекс и рабочий каталог )

если у нас файл уже отслеживается (_**в зеленой зоне**_),
но мы хотим его временно !!! отключить от этого: !!!!!

( от индекса, но не от рабочего каталога ), то

`git rm --cached file-one.txt` - для файла

`git rm --cached -r src` - для директории

флаг `--cached` - операция проводится только с индексом / без рабочей директории

Но после `git add` он снова попадет в стайджинг ареа !!!!

`git rm -f file-one.txt` - если вообще удалить с корнями из папки:

## Переименование файла

---

`git mv script.js app.js` - сразу переименует и в индекс добавит

## Commit

---

> ### _**Правильный коммит**_

1. Указывайте тип коммита:

Этот стиль используется реже

`[ style: open sidebar ]`
`[ fix: function getAllEmployers ]`

`feat:` новая фича, добавляемая к приложению.

`fix:` исправление бага.

`style:` функции и обновления, имеющие отношение к стилизации.

`refactor: `рефакторинг определенного участка кодовой базы.

`test:` все, что касается тестирования.

`docs:` все, что касается документации.

`chore:` обычная поддержка кода, рутина.

2.

`Create function getAllEmployers`

`Refactor subsystem X for readability`

`Update getting started documentation`

`Remove deprecated methods`

`Release version 1.0.0`

Отделяйте заголовок от тела пустой строкой

Ограничивайте заголовок 50 символами

Пишите заголовок с заглавной буквы

Не ставьте точку в конце заголовка

Используйте повелительное наклонение в заголовке

Переходите на следующую строку в теле на 72 символах

В теле отвечайте на вопросы что и почему, а не как

> ### _**Общие команды**_

`git commit -m "Initial commit"`

`git commit --amend` - можно изменить / исправить сам текст коммита !!!!!

`git commit --amend --no-edit` - меняем контент, но оставяем как бы придыдущий коммит и его название

`git show --pretty=fuller` - подробно о коммите

`git commit --author='Anonymous <an@anonumous.com>'` - новый автор коммита

### _**Commit кода частями**_

Бывает надо коммитить только часть кода в одном файле!!!

Важно, чтобы коммит этого кода уже существовал ранее, и новые изменения

вносились в разные участки кода

`git add -p index.html` - мы будем получать код по частям и выбирать `[y,n, ..., ?]` yes, no, ?

### _**Быстрый commit**_

`git commit --all -m 'some text'`

`git commit -a -m 'some text'`

`git commit -am 'some text' `

но флаг -a не учитывает неотслеживаемый ( новый файлы !!!) / то есть все сначала добавить...

### _**Выборочный commit**_

Коммитим быстро только один из файлов: какой-то файл уже проиндексирован,

но мы внесли вдруг изменения в `.gitignore` и хотим именно этот закоммитеть

`git commit -m 'Ignore something' .gitignore` - то есть прямой путь пишем в конце

### _**Commit плюс alias**_

Иногда надо сразу все индексировать/ комитить (даже новые файлы)

Здесь надо делать alias

`git config --global alias.commitall '!git add .; git commit'`

или

`git config --global alias.commitall '!git add -А; git commit'`

## Ветвление

---

> Ветка - изолированный поток разработки, в котором можно делать коммиты,

> невидимые из других мест

`git branch` - информация о ветках

`git branch -v` - информация о ветке и информация о коммите, на который она указывает

`HEAD` - хранит ссылку на текущею ветку

Когда происходит коммит git сначала смотрит, на что указывает `HEAD`

То есть место нашего положения

> ### _Создание новой ветки_

`git branch newBranch` - создание новой ветки newBranch

ветка создана от последнего коммита

`git branch newBranch 37rfjf` - создание новой ветки newBranch от коммита 37rfjf

ветка создана от конкретного коммита

`git checkout newBranch` - переходим на ветку newBranch / по сути мы сместили `HEAD`

Короткий вариант:

`git checkout -b newBranch` - создаст ветку и сразу на нее переключится

Обычно переключение между ветками происходит на чистом состоянии статуса,

иначе изменения просто пропадут. То есть что-то не доделали еще в коде, коммит делать

рано( код сырой), но перейти срочно надо!

Решение ситуации:

Вариант 1

`git checkout --force master` - принудительно переходим, но все теряем незавершенное

( `git checkout -f master` - короткий вариант )

Этот флаг `-f` используют еще и как трюк : то есть накодили что-то не то,

а как все это быстро удалять?

`git checkout -f HEAD` - идем на саму себя как ветку до последнего коммитного состояния

(`git checkout -f` - короткий вариант)

Вариант 2

`git stash` - все удаляестя из поля редактора, но сохранено в специальном архиве

Теперь можно переключиться на др. ветку, а когда вернемся и захотим снова вернуть

несохраненные изменения то укажем:

`git stash pop`

Причем архив `stash` позволяет сохраненные данные вставить в любую ветку!!!!

> ### _Перенос веток вручную_

Ситуация: сделали коммиты в мастер, но оказалось погорячились....

Теперь надо сделать ветку например fix и дальше сменить положение HEAD

уже в мастер, то откатиться на пару лишних комитов, оставив все в fix

Итак, мы в ветке `master`,

теперь создаем ветку `git branch fix`

далее уходим с ветки `master`

и теперь трюк: `git branch -f master 540f`

то есть мы как бы создаем заново ветку мастер от конкретного коммита

В нашем случае мы переместили HEAD на пару коммитов ниже плохих коммитов

А если передумали, то просто снова передвинем на нужное место: головы ветки или коммита

`git branch -f master fix` - master снова равен fix

или

`git branch -f master 45fvrb` - master равен иному состоянию истории

Есть аналогичная команда через `checkout`

`git checkout -B master 4ufh9` - то есть уже существующая ветка `master` будет передвинута

и сразу переключимся на нее

> ### _Состояние отделенного HEAD_

Ничто не мешает перейти сразу на конкретный коммит без указания ветки

`git checkout 45jfjk9` - но теперь мы в особом состоянии `"detached HEAD"`

то есть отделенного _`HEAD`_ - это значит в `HEAD` находится не ветка, а ссылка на конкретный
коммит

Если в этом состоянии сделать изменения и новый коммит, то он не будет привязан ни к какой ветке,

но отталкиваться от родительского коммита.

возвращаться к нему сложно и легко забыть хеш коммита

Сам `git` "предлагает" их преобразовать в отдельную ветку: `git branch <new branch name> 75gjg`

Вообще обычно четко по коммиту переходят только посмотреть старый код,

а коммиты делают по ошибке, забыв где находятся

Но это все решается специальной коммандой:

`git cherry-pick 56768` - передаем коммит (или несколько) и они копируются на текущую ветку,

словно были на ней и сделаны

> ### _Восстановление версий файлов_

Иногда есть необходимость вернуться назад на версию конкретного файла,

который посчитали лучше текущего. При этом нет необходимости переключать ветки и

вообще надо все оставить как есть кроме этого файла

`git checkout 455jf index.html` - ветки не переключаются, а достается только

указанный файл. Можно указывать несколько файлов / директорий...

Теперь файл обновился, и ( смотри `git status`!! ) он папал в индекс !!!

Если сейчас это все закоммитить, то старая версия станет текущей !!!

Если не ходим этого, то убурем из индекса `git reset index.html`

Еще пример с `checkout`:

Мы что-то делали в рабочей директории, но нам эти изменения не нравятся,

мы их хотим отменить, не трогая другие файлы:

`git checkout HEAD index.html` - мы вернулись на последнее сохраненной состояние

Аналог этой же команды по синтаксису без HEAD:

`git checkout index.html`

Итак `git checkout <commit> <path>` - возвращает в рабочую директории из коммита состояние

А `git checkout <path>` - возвращает в рабочую директории из состояние из индекса

> ### _Просмотр Истории_

По умолчанию показываются коммиты от HEAD и вниз....

`git log`

`git log --oneline`

`git log master --oneline` - коммиты ветки master

`git show <commit>` - конкретный коммит

_Чаще всего нужно посмотреть на 1-2-3 коммита назад !!!_

`HEAD` и тильда `~` показывает родительский коммит, то есть один коммит назад

Две тильды `HEAD~~`- родитель родителя ...

`git show HEAD~`

`git show HEAD~~`

Чтобы не писать много тильд, указывается просто номер коммита вниз от текущего

`git show HEAD~2`

`git show HEAD~5`

Сам `HEAD` для краткости можно заменить на собачку `@`

`git show @~4` - в некоторых оболочках ее надо будет взять в кавычки `"@"`

Но такой вывод данных (`git show...`) показывает лишь отличия в файлах!!

> А как посмотреть файлы целиком?

Если мы укажем `git checkout @~ index.html` - то мы увидим в рабочей директории

весь файл, но это изменит и индексации, то есть мы потерям тукущую версию

Поэтому `git show @~:index.html` - мы на шаг назад смотрим терминале index.html

Можно смотреть любой коммит `git show 48jjfr:index.html`

`git show fix:index.html` - смотрим вершину ветки `fix`

Можно увидеть отличия проиндексированной версии (еще нет коммита) от измененной

в этом же коде, но чуть позже после индексации уже: то есть проиндексировали,

но потом что-то изменили.... Смотрим отличия `git show :index.html`

**Никто не помнит индекс коммитов, поэтому иногда ищут по частичному названию**

`git show :/sayHello` - вне зависимости от ветки покажет самую свежую версию

> ### _Слияние веток "перемоткой" (fast-forward)_

Простой вариант слияния веток `master` и `fix` требует, чтобы мы перешли

на ветку `master` и ввели команду: `git merge fix`

Теперь вершиной ветки `master` стал последний коммит ветки `fix`

По сути мы перенесли `HEAD` ветки `master` на вершину ветки `fix`

Если в ветке `fix` оказались какие-то недочеты или мы вообще передумали,

то можно легко вернуть как было все в `master`:

(сначала надо уйти с ветки `master`)

1.

`git branch -f master 4857f` - то есть снова все отрезали до коммита перед слиянием

Но кто этот коммит вообще помнит????

2.

Команда `merge` перед слиянием веток записывает идентификатор в `cat .git/ORIG_HEAD`

Мы его и будем использовать как ссылку:

`git branch -f master ORIG_HEAD`

Если снова захотим передвинуть `HEAD`, то можно уйти с `master` и

`git checkout -B master fix` - по сути это аналог нашего простейшего использования

сляние веток с помощью команды `merge`. Мы как бы ограничились перемещение `HEAD`

> ### _Удаление веток_

Как только мы объединили например `develop` и `fix`, то ветка `fix` может нам

уже и не нужна.

`git branch -d fix` - удаляет ссылку на ветку `fix`

Это удаление пройдет без проблем, так как ветка `fix` объеденена с текущей,

у нее нет отдельных коммитов. Коммиты, на которые нет ссылок наз. недостижимыми,

со временем `git` их удаляет.

`git branch -D feature` - удалит таки ссылку на неслитую с другими ветку

На самом деле еще некоторое время коммиты удаленной ветки будут доступны.

Можно "вернуть" их методом создания новой ветки с таким же названием и указанием

идентификатора (смотри дальше `reflog`) выведенного в журнале при команде удаления:

`git branch feature 7c7d364` - новая ветка, но тоже название и старые коммиты

> ### _История переключения веток, reflog_

Все, что касается переходов с ветками, коммитами связано с идентификаторами коммитов,

которые никто не запоминает. При любой операции, связанной с изменением ссылок `git` записывает

это изменение в спец. файл `reflog` (reference log)

Они находятся в директории `cat .git/logs/`

`git reflog` - выведет `reflog` для `HEAD` от свежич вверху до старых внизу

Например, мы написали функционал в ветке `feature` , слили ее с `develop` и удалили

за ненадобностью. Но решили вернуть. Теперь заходим в `reflog` смотрим подходящую по

описанию действия ссылку и создаем снова ветку `feature` от этого места:

`git branch feature HEAD@{2}`

У команды `git reflog` много опций. По умолчанию она означает `git reflog show`,

то есть просто вывод ссылок с описаниями. Но можно и удалять записи ... (см. `git help reflog`)

Ее полным саналогом будет команда `git log --oneline -g`

`git reflog --no-decorate` - болие краткий вывод данных.

Дополнительно удобно искать по датам `git reflog --date=iso`

Это позволит восстановить удаленную ветку, указав дату:

`git branch feature HEAD@{2021-06-17 14:38:42 +0200}`

Но записи в `reflog` не бесконечно хранятся: обычно 90 дней и 30 дней для недостижимых коммитов

Если делится ветками или отправлять их на сервер, то рефлоги с коммитами не уйдут,

а останутся только у автора

Есть еще один интересный способ перехода на ветку:

`git checkout @{-1}` - были на `develop` и вернулись на `master`

То есть такие вызовы будут чередовать две рабочие ветки: туда-сюда.

Можно еще короче: `git checkout -`

> ### _Удаление "лишних" файлов и незакоммиченных изменений_

Помним команду `git checkout -f` или `git checkout -f index.html` с разными опциями
(см. Перенос веток вручную);

Похожая команда `git reset --hard`

Но они ничего не деляют с неотслеживаемыми файлами!

Для полной очистки надо две команды:

1. `git reset --hard`

2. `git clean -dxf` - снесет все, даже игнорируемые через `.gitignore`

## Reset

---

Часто ошибки уже в репозитории. Удобно отменить последний коммит или несколько последних.

`git reset 49jg95` - мы передали коммит, на который хотим вернуться

Чаще всего важно отменить именно последний коммит.

Помним, что тильда `" ~ "` даст родителя, а `HEAD` заменяется собачкой `@`

`git reset @~` - это один коммит назад

> ### _Вариант `"reset --hard"`_

Чаще всего используется для отмены последних коммитов и незакомиченных изменений.

`git reset --hard 45bvjf` - мы откатились на конкретный коммит.

Это значит, что, например, `HEAD master` будет указывать на него, а

состояние и директории и индекса тоже в порядке, все завершено.

Старый коммит не учавствует в разработке и со временем будет удален.

Если уже шла разработка, после отката, но передумали, то по сути надо снова найти

отресетений коммит и ввести ту же команду `git reset --hard 45bvjf`.

Но кто его помнит?

1. То есть снова идем в `git reflog master` и ищем его.

2. Команда `reset` записывает удаленный коммит в `cat .git/ORIG_HEAD`

Просто вводим `git reset --hard ORIG_HEAD`

То есть, по сути комманда `git reset --hard 454hfj` обратима.

Но одно исключение - пропадут незакомиченные изменения!

Это иногда используют для локальной очистки файлов с изменениями:

что-то поэксперементировали, но не заккомитили, а теперь очистим:

`git reset --hard HEAD` - остаемся на текущем коммите, но без незакомиченных

изменений.

> ### _Вариант `"reset --soft"`_

Действует аналогично `reset --hard`, но не трогает изменения в коде и индексе,

то есть удаляет сам коммит, но оставляет соответствовавшее ему состояние кода.

`git reset --soft @~` - удалит последний коммит, но не его код и регистрацию

Это очень удобно исправить что-то в недавнем коде.

`git reset --soft ORIG_HEAD` - это, если передумали...

На практике:

1. откатились на шаг назад `git reset --soft @~`

2. внесли изменения и добавили их `git add ...`

3. можно оставить название удаленного коммита: `git commit -c ORIG_HEAD`

4. маленький флаг `-c` откроет редактор, а большой `-C` оставит как было

5. флаг `-c/C` оставит старую дату и автора!!!

`ВАЖНО!!!!`

`git reset --soft @~2` - откатит на два коммита назад, но сохранит состояние на момент

самого верхнего коммита, а не на два шага назад!!!

То есть можно откатиться назад, и объединить "функционал будущего"
из двух коммитов под одним новым!!!

> ### _Работа с флагом `"--amend"`_

Порядок действий:

1. Исправляем что-то в коде.

2. `git add ...`

3. `git commit --amend`

Открывается редактор для правки коммита! И оставляем/редактируем

Итак, команда `git commit --amend` сделала следующее:

1. `git reset --soft @~` то есть сдвинула на шаг назад

2. обновила текст коммита

Опции:

`git commit --amend --no-edit` - отменит вызов редактора

`git commit --amend -m "..."` - сразу заменит текст коммита

`git commit --amend --reset=author` - текущий коммитер станет автором

`ОГРАНИЧЕНИЯ`, которые накладываются и на `--amend`, и на `reset --soft` связаны с тем,

они работают лишь с последними коммитами по порядку,

в середину не попадешь (не трогая предыдущий)

> ### _Вариант `"reset --mixed"`_

Режим по-умолчанию! То есть можно писать `git reset @~`

`--hard` - сносит все: коммит, индекс, изменения

`--soft` - сносит коммит, не трогая индекс и код

`--mixed` - сносит коммит и индекс

То есть можно внести изменения и заново проиндексивровать любые файлы

Важное использование этого ресета: сброс текущего индекса `git reset HEAD`.

Например, внесли изменения и поспешили закоммитить... А так можно сбросить текущую

индексацию и что-то другое закоммитеть.

Важное отличие от других: можно указывать путь сброса `git reset index.html`

Это антипод комманды `git add index.html`

## Просмотр истории diff, log ...

---

`git diff <commit1> <commit2>` - покажет разницу между коммитами

`git diff master feature` - покажет разницу между ветками

`git diff master..feature` - абсолютный аналог

`git diff master...feature` - покажет, что именно изменилось в `feature` смомента ее

отхождения от `master`. То есть сравнит два коммита.

Можно и в обратную сторону запустить `git diff feature...master` - покажет новое

в ветке `master` с момента ее расхождения с `feature`

`q` - выходим из листалки

Если указать только один коммит `git diff <commit>`, то будет сравнение рабочей

директории с состоянием на момент коммита.

САМАЯ ПОПУЛЯРНАЯ ВЕРСИЯ комманды это `git diff HEAD` или `git diff @`

Суть: что-то накодили и теперь смотрим какие различия с версией на момент коммита.

Иногда пишут просто `git diff`, но есть разница:

если изменения уже добавлены в индекс, то они не выведутся.

Неотслеживаемые файлы комманда `diff` игнорирует

Важно: `git diff --cached` или `git diff --staged` покажет различия между

тем, что уже в индексе и предыдущим коммитом. То есть то, что осталось только закоммитеть.

Есть комманда `git commit -v` - откроет в редакторе сообщение о коммите, но с демонстрацией

изменений от `diff`.

Далеко не все файлы нам надо порой сравнивать:

`git diff index.html` - выведет изменения только для одного файла

(рабочая версия и индекс, так как не указан коммит сам!!!) (иначе пиши `git diff HEAD index.html`)

`git diff .` - в текущей директории целиком

`git diff master feature index.html` - различия в ветках только для `index.html`

Если различий очень много, то коммнада `git diff --name-only master feature`

покажет только пути(файлы), которые различаются, а потом уже сам выбирай.

Просто двойной дефис `--` это опция для страховки: `git diff -- index.html`

Она говорит, что сейчас пойдет путь (файл). Мы же можем назвать файл и `master` ...

> ### _Комманда `"git log"`_

`git log`

`git log --pretty=medium` - по умолчанию

`git log --pretty=oneline` - короче формат: идентификатор плюс заголовок

`git log --pretty=oneline --abbrev-commit ` - короче формат идентийикаторов самих

`git log --oneline` - короткий вариант двух последних комманд

По-умолчанию `git log --oneline` выводит ссылки на коммиты (HEAD > master) ...

Ее полный вариант `git log --oneline --decorate=short `

Если хотим от этого отказаться, то `git log --oneline --no-decorate `

У флага `--pretty` много опций (см. `git help log`)

Например, `git log --pretty=format:'%h %cd | %s%d [%an]'`

Или `git log --pretty=format:'%h %cr | %s%d [%an]'` - дата как "5 days ago"

Или `git log --pretty=format:'%h %cd | %s%d [%an]' --date=short`

Но мы потеряли цвета в процессе вывода...

Исправим это через `%C(yellow)%h` то есть:

`git log --pretty=format:'%C(yellow)%h %cd | %s%d [%an]' --date=short`

Добавим еще цвет:

`git log --pretty=format:'%C(yellow)%h %C(dim green)%cd | %s%d [%an]' --date=short`

И еще:

`git log --pretty=format:'%C(yellow)%h %C(dim green)%cd | %C(red)%s%d %C(white)[%an]' --date=short`

Вместо названий цветов можно использовать `rgb` то есть `%C(#FRE78)`

Но лучше сделать глобальный `alias`:

`git config --global pretty.my format:'%C(#f3f89d)%h %C(#418d61)%cd %C(reset)|%C(#F78972)%d %C(#9aedf1)%s'`

Затем сократим комманду `git config --global format.pretty my`

Теперь обычный `git log` даст этот формат

Можно укоротить дату вывода и локализировать ее:

git config --global log.date format-local:'%F %R'

Теперь `git log` еще удобнее выводит

А если понадобиться снова длинный то, `git log --pretty=medium`

> Есть еще важный флаг `--patch` или просто `-p`

`git log -p` - добавляет к каждому коммиту diff (отличия) того, что было сделано / изменено
