# Git CheatSheet

## 1.1 `Git` - Конфигурация

---

`git init` - создает пустой репозитоий в корне проекта

> GIT не умеет работать с упустыми папками: надо что-то туда положить: обычно это `.gitkeep`

`cat .git/config` - данные о репозитории

если локально указать данные о себе под конкретный проект:

`git config user.name "Louis-Ferdinand"`, то они выведутся

`git config --list --global ` - смотрим все глобальные настройки

`cat ~/.gitconfig ` - проще всего смотреть настройки

## 1.2 `Git` - `Alias`

---

`git config --global alias.c config` - теперь просто жмем `git c`

`git config --global alias.c 'config --global'` - теперь просто жмем `git c --list`

## 1.3 `Git` - Общие моменты

---

`git log --oneline` - должен показать все коммиты

`git status`

`git add file.txt `

`git add .` - add everything / текущее

`git add -A` - вообще все индексирует начиная с корня проекта

Если после `git add .` мы удалили `file-one.txt`,

то нужно снова провести `git add .` или `git add file-one.txt`
то есть обновить стайджинг ареа

## 1.4 `Git` - Удаление

---

`git rm file.txt ` - полное удаление файла ( и индекс и рабочий каталог )

`git rm -r src` - полное удаление директории ( и индекс и рабочий каталог )

если у нас файл уже отслеживается (_**в зеленой зоне**_),
но мы хотим его временно !!! отключить от этого: !!!!!

( от индекса, но не от рабочего каталога ), то

`git rm --cached file-one.txt` - для файла

`git rm --cached -r src` - для директории

флаг `--cached` - операция проводится только с индексом / без рабочей директории

Но после `git add` он снова попадет в стайджинг ареа !!!!

`git rm -f file-one.txt` - если вообще удалить с корнями из папки:

## 1.5 `Git` - Переименование файла

---

`git mv script.js app.js` - сразу переименует и в индекс добавит

## 2.1 `Git` - Коммит - Правильный коммит

---

1. Указывайте тип коммита:

Этот стиль используется реже

`[ style: open sidebar ]`
`[ fix: function getAllEmployers ]`

`feat:` новая фича, добавляемая к приложению.

`fix:` исправление бага.

`style:` функции и обновления, имеющие отношение к стилизации.

`refactor: `рефакторинг определенного участка кодовой базы.

`test:` все, что касается тестирования.

`docs:` все, что касается документации.

`chore:` обычная поддержка кода, рутина.

2.

`Create function getAllEmployers`

`Refactor subsystem X for readability`

`Update getting started documentation`

`Remove deprecated methods`

`Release version 1.0.0`

Отделяйте заголовок от тела пустой строкой

Ограничивайте заголовок 50 символами

Пишите заголовок с заглавной буквы

Не ставьте точку в конце заголовка

Используйте повелительное наклонение в заголовке

Переходите на следующую строку в теле на 72 символах

В теле отвечайте на вопросы что и почему, а не как

## 2.2 `Git` - Коммит - Общие команды

---

`git commit -m "Initial commit"`

`git commit --amend` - можно изменить / исправить сам текст коммита !!!!!

`git commit --amend --no-edit` - меняем контент, но оставяем как бы придыдущий коммит и его название

`git show --pretty=fuller` - подробно о коммите

`git commit --author='Anonymous <an@anonumous.com>'` - новый автор коммита

## 2.3 `Git` - Коммит - Коммит кода частями

---

Бывает надо коммитить только часть кода в одном файле!!!

Важно, чтобы коммит этого кода уже существовал ранее, и новые изменения

вносились в разные участки кода

`git add -p index.html` - мы будем получать код по частям и выбирать `[y,n, ..., ?]` yes, no, ?

## 2.4 `Git` - Коммит -Быстрый коммит

---

`git commit --all -m 'some text'`

`git commit -a -m 'some text'`

`git commit -am 'some text' `

но флаг -a не учитывает неотслеживаемый ( новый файлы !!!) / то есть все сначала добавить...

## 2.5 `Git` - Коммит - Выборочный коммит

Коммитим быстро только один из файлов: какой-то файл уже проиндексирован,

но мы внесли вдруг изменения в `.gitignore` и хотим именно этот закоммитеть

`git commit -m 'Ignore something' .gitignore` - то есть прямой путь пишем в конце

## 2.6 `Git` - Коммит - Коммит плюс `alias`

Иногда надо сразу все индексировать/ комитить (даже новые файлы)

Здесь надо делать alias

`git config --global alias.commitall '!git add .; git commit'`

или

`git config --global alias.commitall '!git add -А; git commit'`

## 3.1 `Git` – Ветки – Введение

---

> Ветка - изолированный поток разработки, в котором можно делать коммиты,

> невидимые из других мест

`git branch` - информация о ветках

`git branch -v` - информация о ветке и информация о коммите, на который она указывает

`HEAD` - хранит ссылку на текущею ветку

Когда происходит коммит git сначала смотрит, на что указывает `HEAD`

То есть место нашего положения

Мы може посмотреть с какими ветками объеденена текущая:

`git branch --merged` - все объеденненные с текущей веткой

`git branch --no-merged` - все не объеденненные с текущей веткой

## 3.2 `Git` – Ветки – Создание и переключение

---

`git branch newBranch` - создание новой ветки `newBranch`

ветка создана от последнего коммита

`git branch newBranch 37rfjf` - создание новой ветки `newBranch` от коммита `37rfjf`

ветка создана от конкретного коммита

`git checkout newBranch` - переходим на ветку `newBranch` / по сути мы сместили `HEAD`

Короткий вариант:

`git checkout -b newBranch` - создаст ветку и сразу на нее переключится

## 3.3 `Git` – Ветки – Команда `checkout` при незакоммиченных изменениях

---

Обычно переключение между ветками происходит на чистом состоянии статуса,

иначе изменения просто пропадут. То есть что-то не доделали еще в коде, коммит делать

рано( код сырой ), но перейти срочно надо!

Решение ситуации:

Вариант 1

`git checkout --force master` - принудительно переходим, но все теряем незавершенное

( `git checkout -f master` - короткий вариант )

Этот флаг `-f` используют еще и как трюк : то есть накодили что-то не то,

а как все это быстро удалять?

`git checkout -f HEAD` - идем на саму себя как ветку до последнего коммитного состояния

(`git checkout -f` - короткий вариант)

Вариант 2

`git stash` - все удаляестя из поля редактора, но сохранено в специальном архиве

Теперь можно переключиться на др. ветку, а когда вернемся и захотим снова вернуть

несохраненные изменения то укажем:

`git stash pop`

Причем архив `stash` позволяет сохраненные данные вставить в любую ветку!!!!

## 3.4 `Git` – Ветки – Перенос веток "вручную"

---

Ситуация: сделали коммиты в мастер, но оказалось погорячились....

Теперь надо сделать ветку например fix и дальше сменить положение HEAD

уже в мастер, то откатиться на пару лишних комитов, оставив все в fix

Итак, мы в ветке `master`,

теперь создаем ветку `git branch fix`

далее уходим с ветки `master`

и теперь трюк: `git branch -f master 540f`

то есть мы как бы создаем заново ветку мастер от конкретного коммита

В нашем случае мы переместили HEAD на пару коммитов ниже плохих коммитов

А если передумали, то просто снова передвинем на нужное место: головы ветки или коммита

`git branch -f master fix` - master снова равен fix

или

`git branch -f master 45fvrb` - master равен иному состоянию истории

Есть аналогичная команда через `checkout`

`git checkout -B master 4ufh9` - то есть уже существующая ветка `master` будет передвинута

и сразу переключимся на нее

## 3.5 `Git` – Ветки – Состояние отделённой `HEAD`

Ничто не мешает перейти сразу на конкретный коммит без указания ветки

`git checkout 45jfjk9` - но теперь мы в особом состоянии `"detached HEAD"`

то есть отделенного _`HEAD`_ - это значит в `HEAD` находится не ветка, а ссылка на конкретный
коммит

Если в этом состоянии сделать изменения и новый коммит, то он не будет привязан ни к какой ветке,

но отталкиваться от родительского коммита.

возвращаться к нему сложно и легко забыть хеш коммита

Сам `git` "предлагает" их преобразовать в отдельную ветку: `git branch <new branch name> 75gjg`

Вообще обычно четко по коммиту переходят только посмотреть старый код,

а коммиты делают по ошибке, забыв где находятся

Но это все решается специальной коммандой:

`git cherry-pick 56768` - передаем коммит (или несколько) и они копируются на текущую ветку,

словно были на ней и сделаны

## 3.6 Git – Ветки – Восстановление предыдущих версий файлов

---

Иногда есть необходимость вернуться назад на версию конкретного файла,

который посчитали лучше текущего. При этом нет необходимости переключать ветки и

вообще надо все оставить как есть кроме этого файла

`git checkout 455jf index.html` - ветки не переключаются, а достается только

указанный файл. Можно указывать несколько файлов / директорий...

Теперь файл обновился, и ( смотри `git status`!! ) он папал в индекс !!!

Если сейчас это все закоммитить, то старая версия станет текущей !!!

Если не ходим этого, то убурем из индекса `git reset index.html`

Еще пример с `checkout`:

Мы что-то делали в рабочей директории, но нам эти изменения не нравятся,

мы их хотим отменить, не трогая другие файлы:

`git checkout HEAD index.html` - мы вернулись на последнее сохраненной состояние

Аналог этой же команды по синтаксису без HEAD:

`git checkout index.html`

Итак `git checkout <commit> <path>` - возвращает в рабочую директории из коммита состояние

А `git checkout <path>` - возвращает в рабочую директории из состояние из индекса

> ### _Просмотр Истории_

По умолчанию показываются коммиты от HEAD и вниз....

`git log`

`git log --oneline`

`git log master --oneline` - коммиты ветки master

`git show <commit>` - конкретный коммит

_Чаще всего нужно посмотреть на 1-2-3 коммита назад !!!_

`HEAD` и тильда `~` показывает родительский коммит, то есть один коммит назад

Две тильды `HEAD~~`- родитель родителя ...

`git show HEAD~`

`git show HEAD~~`

Чтобы не писать много тильд, указывается просто номер коммита вниз от текущего

`git show HEAD~2`

`git show HEAD~5`

Сам `HEAD` для краткости можно заменить на собачку `@`

`git show @~4` - в некоторых оболочках ее надо будет взять в кавычки `"@"`

Но такой вывод данных (`git show...`) показывает лишь отличия в файлах!!

> А как посмотреть файлы целиком?

Если мы укажем `git checkout @~ index.html` - то мы увидим в рабочей директории

весь файл, но это изменит и индексации, то есть мы потерям тукущую версию

Поэтому `git show @~:index.html` - мы на шаг назад смотрим терминале index.html

Можно смотреть любой коммит `git show 48jjfr:index.html`

`git show fix:index.html` - смотрим вершину ветки `fix`

Можно увидеть отличия проиндексированной версии (еще нет коммита) от измененной

в этом же коде, но чуть позже после индексации уже: то есть проиндексировали,

но потом что-то изменили.... Смотрим отличия `git show :index.html`

**Никто не помнит индекс коммитов, поэтому иногда ищут по частичному названию**

`git show :/sayHello` - вне зависимости от ветки покажет самую свежую версию

> ### _Слияние веток "перемоткой" (fast-forward)_

Простой вариант слияния веток `master` и `fix` требует, чтобы мы перешли

на ветку `master` и ввели команду: `git merge fix`

Теперь вершиной ветки `master` стал последний коммит ветки `fix`

По сути мы перенесли `HEAD` ветки `master` на вершину ветки `fix`

Если в ветке `fix` оказались какие-то недочеты или мы вообще передумали,

то можно легко вернуть как было все в `master`:

(сначала надо уйти с ветки `master`)

1.

`git branch -f master 4857f` - то есть снова все отрезали до коммита перед слиянием

Но кто этот коммит вообще помнит????

2.

Команда `merge` перед слиянием веток записывает идентификатор в `cat .git/ORIG_HEAD`

Мы его и будем использовать как ссылку:

`git branch -f master ORIG_HEAD`

Если снова захотим передвинуть `HEAD`, то можно уйти с `master` и

`git checkout -B master fix` - по сути это аналог нашего простейшего использования

сляние веток с помощью команды `merge`. Мы как бы ограничились перемещение `HEAD`

> ### _Удаление веток_

Как только мы объединили например `develop` и `fix`, то ветка `fix` может нам

уже и не нужна.

`git branch -d fix` - удаляет ссылку на ветку `fix`

Это удаление пройдет без проблем, так как ветка `fix` объеденена с текущей,

у нее нет отдельных коммитов. Коммиты, на которые нет ссылок наз. недостижимыми,

со временем `git` их удаляет.

`git branch -D feature` - удалит таки ссылку на неслитую с другими ветку

На самом деле еще некоторое время коммиты удаленной ветки будут доступны.

Можно "вернуть" их методом создания новой ветки с таким же названием и указанием

идентификатора (смотри дальше `reflog`) выведенного в журнале при команде удаления:

`git branch feature 7c7d364` - новая ветка, но тоже название и старые коммиты

> ### _История переключения веток, reflog_

Все, что касается переходов с ветками, коммитами связано с идентификаторами коммитов,

которые никто не запоминает. При любой операции, связанной с изменением ссылок `git` записывает

это изменение в спец. файл `reflog` (reference log)

Они находятся в директории `cat .git/logs/`

`git reflog` - выведет `reflog` для `HEAD` от свежич вверху до старых внизу

Например, мы написали функционал в ветке `feature` , слили ее с `develop` и удалили

за ненадобностью. Но решили вернуть. Теперь заходим в `reflog` смотрим подходящую по

описанию действия ссылку и создаем снова ветку `feature` от этого места:

`git branch feature HEAD@{2}`

У команды `git reflog` много опций. По умолчанию она означает `git reflog show`,

то есть просто вывод ссылок с описаниями. Но можно и удалять записи ... (см. `git help reflog`)

Ее полным саналогом будет команда `git log --oneline -g`

`git reflog --no-decorate` - болие краткий вывод данных.

Дополнительно удобно искать по датам `git reflog --date=iso`

Это позволит восстановить удаленную ветку, указав дату:

`git branch feature HEAD@{2021-06-17 14:38:42 +0200}`

Но записи в `reflog` не бесконечно хранятся: обычно 90 дней и 30 дней для недостижимых коммитов

Если делится ветками или отправлять их на сервер, то рефлоги с коммитами не уйдут,

а останутся только у автора

Есть еще один интересный способ перехода на ветку:

`git checkout @{-1}` - были на `develop` и вернулись на `master`

То есть такие вызовы будут чередовать две рабочие ветки: туда-сюда.

Можно еще короче: `git checkout -`

## 4.1 `Git` – Удаление "лишних" файлов и незакоммиченных изменений

---

Помним команду `git checkout -f` или `git checkout -f index.html` с разными опциями
(см. Перенос веток вручную);

Похожая команда `git reset --hard`

Но они ничего не деляют с неотслеживаемыми файлами!

Для полной очистки надо две команды:

1. `git reset --hard`

2. `git clean -dxf` - снесет все, даже игнорируемые через `.gitignore`

## 5.1 `Git` - `Reset` Жесткий `reset --hard`: отмена изменений

---

Часто ошибки уже в репозитории. Удобно отменить последний коммит или несколько последних.

`git reset 49jg95` - мы передали коммит, на который хотим вернуться

Чаще всего важно отменить именно последний коммит.

Помним, что тильда `" ~ "` даст родителя, а `HEAD` заменяется собачкой `@`

`git reset @~` - это один коммит назад.

Чаще всего жесткий `"reset --hard"` используется для отмены последних коммитов и незакомиченных изменений.

`git reset --hard 45bvjf` - мы откатились на конкретный коммит.

Это значит, что, например, `HEAD master` будет указывать на него, а

состояние и директории и индекса тоже в порядке, все завершено.

Старый коммит не учавствует в разработке и со временем будет удален.

Если уже шла разработка, после отката, но передумали, то по сути надо снова найти

отресетений коммит и ввести ту же команду `git reset --hard 45bvjf`.

Но кто его помнит?

1. То есть снова идем в `git reflog master` и ищем его.

2. Команда `reset` записывает удаленный коммит в `cat .git/ORIG_HEAD`

Просто вводим `git reset --hard ORIG_HEAD`

То есть, по сути комманда `git reset --hard 454hfj` обратима.

Но одно исключение - пропадут незакомиченные изменения!

Это иногда используют для локальной очистки файлов с изменениями:

что-то поэксперементировали, но не заккомитили, а теперь очистим:

`git reset --hard HEAD` - остаемся на текущем коммите, но без незакомиченных

изменений.

## 5.2 `Git` – `Reset` – Мягкий `reset --soft`: замена и объединение коммитов

---

Действует аналогично `reset --hard`, но не трогает изменения в коде и индексе,

то есть удаляет сам коммит, но оставляет соответствовавшее ему состояние кода.

`git reset --soft @~` - удалит последний коммит, но не его код и регистрацию

Это очень удобно исправить что-то в недавнем коде.

`git reset --soft ORIG_HEAD` - это, если передумали...

На практике:

1. откатились на шаг назад `git reset --soft @~`

2. внесли изменения и добавили их `git add ...`

3. можно оставить название удаленного коммита: `git commit -c ORIG_HEAD`

4. маленький флаг `-c` откроет редактор, а большой `-C` оставит как было

5. флаг `-c/C` оставит старую дату и автора!!!

`ВАЖНО!!!!`

`git reset --soft @~2` - откатит на два коммита назад, но сохранит состояние на момент

самого верхнего коммита, а не на два шага назад!!!

То есть можно откатиться назад, и объединить "функционал будущего"
из двух коммитов под одним новым!!!

## 5.3 `Git` – `Reset` – Правка последнего коммита: `commit --amend`

---

Порядок действий:

1. Исправляем что-то в коде.

2. `git add ...`

3. `git commit --amend`

Открывается редактор для правки коммита! И оставляем/редактируем

Итак, команда `git commit --amend` сделала следующее:

1. `git reset --soft @~` то есть сдвинула на шаг назад

2. обновила текст коммита

Опции:

`git commit --amend --no-edit` - отменит вызов редактора

`git commit --amend -m "..."` - сразу заменит текст коммита

`git commit --amend --reset=author` - текущий коммитер станет автором

`ОГРАНИЧЕНИЯ`, которые накладываются и на `--amend`, и на `reset --soft` связаны с тем,

они работают лишь с последними коммитами по порядку,

в середину не попадешь (не трогая предыдущий)

## 5.4 `Git` – `Reset` – Смешанный `reset` (без флагов), сравнение видов `reset`

Вариант `git reset --mixed` - это режим по-умолчанию! То есть можно писать `git reset @~`.

`--hard` - сносит все: коммит, индекс, изменения

`--soft` - сносит коммит, не трогая индекс и код

`--mixed` - сносит коммит и индекс

То есть можно внести изменения и заново проиндексивровать любые файлы

Важное использование этого ресета: сброс текущего индекса `git reset HEAD`.

Например, внесли изменения и поспешили закоммитить... А так можно сбросить текущую

индексацию и что-то другое закоммитеть.

Важное отличие от других: можно указывать путь сброса `git reset index.html`

Это антипод комманды `git add index.html`

## 6.1 Просмотр – Сравнение коммитов, веток и не только: `git diff`

---

`git diff <commit1> <commit2>` - покажет разницу между коммитами

`git diff master feature` - покажет разницу между ветками

`git diff master..feature` - абсолютный аналог

`git diff master...feature` - покажет, что именно изменилось в `feature` смомента ее

отхождения от `master`. То есть сравнит два коммита.

Можно и в обратную сторону запустить `git diff feature...master` - покажет новое

в ветке `master` с момента ее расхождения с `feature`

`q` - выходим из листалки

Если указать только один коммит `git diff <commit>`, то будет сравнение рабочей

директории с состоянием на момент коммита.

САМАЯ ПОПУЛЯРНАЯ ВЕРСИЯ комманды это `git diff HEAD` или `git diff @`

Суть: что-то накодили и теперь смотрим какие различия с версией на момент коммита.

Иногда пишут просто `git diff`, но есть разница:

если изменения уже добавлены в индекс, то они не выведутся.

Неотслеживаемые файлы комманда `diff` игнорирует

Важно: `git diff --cached` или `git diff --staged` покажет различия между

тем, что уже в индексе и предыдущим коммитом. То есть то, что осталось только закоммитеть.

Есть комманда `git commit -v` - откроет в редакторе сообщение о коммите, но с демонстрацией

изменений от `diff`.

Далеко не все файлы нам надо порой сравнивать:

`git diff index.html` - выведет изменения только для одного файла

(рабочая версия и индекс, так как не указан коммит сам!!!) (иначе пиши `git diff HEAD index.html`)

`git diff .` - в текущей директории целиком

`git diff master feature index.html` - различия в ветках только для `index.html`

Если различий очень много, то коммнада `git diff --name-only master feature`

покажет только пути(файлы), которые различаются, а потом уже сам выбирай.

Просто двойной дефис `--` это опция для страховки: `git diff -- index.html`

Она говорит, что сейчас пойдет путь (файл). Мы же можем назвать файл и `master` ...

## 6.2 Просмотр - Декорированный вывод коммитов

---

`git log`

`git log --pretty=medium` - по умолчанию

`git log --pretty=oneline` - короче формат: идентификатор плюс заголовок

`git log --pretty=oneline --abbrev-commit ` - короче формат идентийикаторов самих

`git log --oneline` - короткий вариант двух последних комманд

По-умолчанию `git log --oneline` выводит ссылки на коммиты (HEAD > master) ...

Ее полный вариант `git log --oneline --decorate=short `

Если хотим от этого отказаться, то `git log --oneline --no-decorate `

У флага `--pretty` много опций (см. `git help log`)

Например, `git log --pretty=format:'%h %cd | %s%d [%an]'`

Или `git log --pretty=format:'%h %cr | %s%d [%an]'` - дата как "5 days ago"

Или `git log --pretty=format:'%h %cd | %s%d [%an]' --date=short`

Но мы потеряли цвета в процессе вывода...

Исправим это через `%C(yellow)%h` то есть:

`git log --pretty=format:'%C(yellow)%h %cd | %s%d [%an]' --date=short`

Добавим еще цвет:

`git log --pretty=format:'%C(yellow)%h %C(dim green)%cd | %s%d [%an]' --date=short`

И еще:

`git log --pretty=format:'%C(yellow)%h %C(dim green)%cd | %C(red)%s%d %C(white)[%an]' --date=short`

Вместо названий цветов можно использовать `rgb` то есть `%C(#FRE78)`

Но лучше сделать глобальный `alias`:

`git config --global pretty.my format:'%C(#f3f89d)%h %C(#418d61)%cd %C(reset)|%C(#F78972)%d %C(#9aedf1)%s'`

Затем сократим комманду `git config --global format.pretty my`

Теперь обычный `git log` даст этот формат

Можно укоротить дату вывода и локализировать ее:

git config --global log.date format-local:'%F %R'

Теперь `git log` еще удобнее выводит

А если понадобиться снова длинный то, `git log --pretty=medium`

> Есть еще важный флаг `--patch` или просто `-p`

`git log -p` - добавляет к каждому коммиту diff (отличия) того, что было сделано / изменено

## 6.3 Просмотр – Вывод истории: `git log`, форматирование коммитов

---

Можно конкретно указывать какие ветки выводить:

`git log master`

`git log master develop`

Можно указать флаг `--graph` чтобы было яснее с ветками

`git log master develop --graph`

`git log --all --graph`

Часто нужно увидеть коммиты, которые произошли на ветке, с момента ее расхождения

с другой веткой. То сеть смотрим, что было сделано на ветке `feature` когда она

отделилась от ветки `master`. Причем коммиты, сделанные еще в `master` нам видеть не надо

`git log feature ^master` - каретка `^` уберет из списка коммиты ветки `master`

Есть полный аналог `git log master..feature`

В нашем случае `master` являлся HEAD для ветки `feature`, поэтому можно короче указать:

`git log HEAD..feature` === `git log ..feature`

Можно в обратную сторону `git log feature..master` - разработка `master` которой нет в `feature`

Во всех случаях не будет виден пограничный коммит( на котором разделились !),

если же он нужен, то `git log feature..master --boundary`

## 6.4 Просмотр – Вывод `git log` коммитов, меняющих нужный файл

---

`git log index.html`

`git log -p index.html` - вывод по частям именно изменений

`git log --follow app.js` - если файл был переименован, то флаг `--follow` найдет

и покажет коммиты и для старого файла тоже

`git log master..feature app.js` - то есть коммиты только ветки `feature` и только для `app.js`

## 6.5 Просмотр - Флаги-фильтры, поиск по свойствам

По умолчаниею поиск регистрозависимый!!!

Мы ищем по словам, но на самом деле поиск идет по регулярным выражениям.

`git log --grep Create` - флаг `--grep` даст вывод всех коммитов со словом `Create` текущей ветки

`git log --grep create -i` - дополнительный флаг `-i` уберет регистрозависимость

`git log --grep Create feature` - вывод всех коммитов со словом `Create` ветки `feature`

`git log --grep Create master..feature` - только уникальные для ветки `feature`

Можно искать сразу по разным словам в описании коммитов:

`git log --grep Create --grep modify` - только уникальные для ветки `feature` - даст коммиты,

которые содержат либо одно, либо другое слово

А вот флаг `--all-match` поможет объеденить поиск

`git log --grep Create --grep function--all-match` - даст все коммиты с `Create function`

## 6.6 Просмотр – Кто написал эту строку? `git blame`

---

Часто надо искать не по названию коммитов, а по изменениям в тексте кода.

Иногда это довольно сложно. Поэтому флаг `-G` поможет вывести коммиты, в которых изменялась,

например, функция `getElement`:

`git log -GgetElement` - только коммиты с функцией `getElement`

`git log -G'function getElement' -p app.js` - вывод истории изменений `function getElement`

с демонстрацией изменений "`-p`" и только для файла `app.js`

Есть важный флаг `-L`: бывает важно найти коммиты, которые меняют само тело функции!!!

То есть менялся внутренний кщд функции. Пишем регурярное выражение,

где началом будет `"function getElement"`, а концом `"}"`

`git log -L '/^function getElement/','/^}/':app.js`

Можно искать по автору: `git log --author=Louis-Ferdinand`

или по коммитеру

`git log --commiter=bob`

или по дате в разных форматах

`git log --before '3 days ago`

`git log --before '2021-09-13`

`git log --after '2019-02-22 08:30:00`

Можно узнать, кто написал конкретную строку в каком-то файле: `git blame app.js`

## 7.1 Слияние – "Истинное" слияние и разрешение конфликтов в `git merge`

---

Слияние веток "перемоткой" просто смещало `HEAD` ветки `master` на вершину ветки `feature`.

А если у нас в ветке `master` уже делались свои собственные независимые коммиты,

отличные от структуры файлов `feature`?

Тогда вершиной `master` станет последний коммит `feature`, а независимые коммиты `master` пропадут.

Поэтому "истинное слияние" предполагает анализ файлов веток и создание нового коммита, с учетом отличий!

Желательно, чтобы статус перед слиянием был чистым.

Итак на ветке `master` указываем: `git merge feature`

Теперь `git` проверит общий базовый `base` коммит до разделения, затем вершину `master` то есть `ours`,

затем вершину ветки `feature` то есть `theirs`.

> Конфликт

Файлы из разных веток могут различаться в своих фрагментах кода! Какой выбрать как базовый?

Мы вводим `git merge feature` и получаем конфликт( редактор поможет с подсветкой различий!!!).

Обычно новейшая версия - это то, что в ветке `master`, тогда мы указываем:

`git checkout --ours app.js` - возьмет версию `app.js` из `master`

`git checkout --theirs app.js` - возьмет версию `app.js` из `feature`

Если мы снова хотим посмотреть на маркеры конфликта в файле, то: `git checkout --merge app.js`

Если "к черту это слияние", то `git reset --hard` - снесет все до чистого закомиченого состояния `master`

Аккуратнее работает `git reset --merge` - оставляет незакоммиченые изменения в файлах,

которые не учавствовали в слиянии! - то есть одинаковые в обеих ветках!

Абсолютный аналог - это команда `git merge --abort`

Если мы хотим увидеть, что было в конфликтном файле до разделения веток,

то можно указать `git checkout --conflict=diff3 --merge app.js` - основа до разделения

будет представлена в маркере `||||base`

Далее в редакторе исправляем разногласия кода. Затем снова вносим файл в индекс `git add app.js`,

после делаем коммит или используем специальную красивую комманду `git merge --continue` ее сделали для красоты.

## 7.2 Коммит слияния

---

Теперь вершиной `master` станет особый коммит слияния, у которого два родителя!

`git show` - покажет как разрешилиськонфликты

`git show --first-parent` - то, что добавлено нового в `master`

Но на практике для просмотра отличий удобней использовать `git diff`

Используем каретку `"^"` для работы с коммитом слияния

`git diff HEAD^1` или просто `git diff @^` - изменения по сравнению с первым родителем - то есть

это предпоследний коммит ветки `master`

`git diff HEAD^2` - это вершина второго родителя - то есть вершина `feature`

`git diff HEAD^^` - родитель родителя коммита слияния (пред предпоследний в `master`)

`git diff HEAD^2^` - родитель вершины `feature`

Мы може посмотреть с какими ветками объеденена текущая:

`git branch --merged` - все объеденненные с текущей веткой

`git branch --no-merged` - все не объеденненные с текущей веткой

Смотрим историю коммитов ветки `master` обычным способом

`git log master --oneline`

Но она выводит коммиты и от слитых веток! Поэтому комманда:

`git log master --oneline --first-parent` - даст только коммиты первого родителя!

## 7.3 Отмена слияния

---

Отмена происходит также как и отмена коммитов.

`git reset --hard @~` - откатились на коммит назад

Команда также по сути обратима!

Находим нужный коммит: `git reflog -4` (вывод последних 4 записей)

Далее, например, `git reset --hard @{2}` - то есть нашли запись, где указывался `merge`

## 7.4 Слияние – Семантические конфликты и их разрешение

---

Может быть ситуация семантического конфликта - конфликт изменений по смыслу, а не по месту в файле.

Например, функция вызвана в одном файле с аргументов, а в другом - без.

Если такой коммит произошел, то, чтобы не портить историю плохим коммитом в репозитории,

сначала откатываемся назад: `git reset --hard @~`

Затем возвращаемся к слиянию, но с флагом `--no-commit`, это позволит провести процесс прерванного

слияния, но остановиться перед коммитом: `git merge feature --no-commit`

Теперь вносим правки, добавим последние изменения в индекс: `git add app.js` и реализуем слияние:

`git merge --continue` или аналог `git commit --no-edit`

## 7.5 Слияние – Полезный приём: сохранение веток с флагом `--no-ff`

---

Можно провести полноценное слияние даже там, где легко обойтись и просто перемоткой.

Иногда ошибки обнаруживаются через длительное время и откат `git reset --hard ORIG_HEAD`

уже будет неуместен. Коммиты после слияния "перемоткой" слиты в один поток ...

От этой проблемы избавляются запретом перемотки:

Флаг `--no-ff` заставляет вместо перемотки делать коммит слияния.

`git merge --no-ff --no-edit feature` - теперь у нас истинное слияние в "режиме перемотки".

Если мы захотим потом отказаться, то будет легко отменить именно этот коммит

`git reset --gard @~`

Обозначенная проблема с перемоткой настолько стандартна, что естьспециальные настройки:

`git config merge.ff false` - значит флаг `--no-ff` поставлен по умолчанию

Либо настройки по конкретную ветку, например, `mster`:

`git config branch.master.mergeoptions '--no-ff'`

Но если перемотка нам понадобится где-то явно уже,

то можно включить флаг: `git merge --ff feature`

## 7.6 Слияние – Создание коммита из ветки: `merge --squash`

---

Иногда у нас есть мальнькая ветка с хорошим результатом, но совершенно дикой

историей коммитов, которую никак нельзя предать огласки!

`git merge --squash fix` - берем результат ветки `fix`, объединяем в рабочей директорией

и потом просто коммитим как один единственный коммит! Без всякой связи с веткой `fix`!

Коммит будет с одним родителем. `MERGE_HEAD` не создается, а ведь именно из него,

создается второй родитель.

Все это даст побочный эффект:

флаги `git merge --abort` и `git merge --continue` не будут работать.

Но будет работать аналог `--abort` в виде `git reset --merge`.

Также остается рабочим `git reset --hard`.

Для завершения слияние вместо `git merge --continue` используем обычный коммит.

## 8.1 Копирование коммитов – Копирование коммитов: cherry-pick

---

Бывает ситуация, когда у нас есть две ветки с разными версиями, а ошибка обнаружена

в обеих ветках. Мы можем ошибку исправить в одной ветке, сделать коммит, а потом,

находясь на основной ветке, его скопировать `git cherry-pick <commit>`.

Теперь он вершина ветки.

Можно копировать несколько коммитов перечислением:

`git cherry-pick <commit 1> <commit 2>`

Либо указать диапазон `git cherry-pick master..feature`. То есть будут

скопированы все коммиты ветки `feature`, которых не в `master`.

Но в такой ситуации могут быть конфликты в различиях файлов.

Команда `git cherry-pick --abort` отменит все и вернет как было до `cherry-pick`.

Но только при незавершенном копировании.

Команда `git cherry-pick --continue` продолжит копирование после разрешения конфликта.

Команда `git cherry-pick --quit` остановиться там, где мы сейчас. То есть остаются успешно

скопированные коммиты, а конфликтные нет.

Как полностью отказаться от завершенного копирования?

Общая схема с жестким ресетом: `git reset --hard @~` - или на сколько нужно

шагов назад: `@~2 ...`

Иногда надо скопировать изменения, но без того, чтобы сразу создался коммит:

`git cherry-pick --no-commit <commit>` или `git cherry-pick -n <commit>`
